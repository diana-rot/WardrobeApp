{% extends "base.html" %}

{% block title %}Add Clothes to Wardrobe - WardrobeApp{% endblock %}

{% block extra_css %}
<style>
    .card {
        background-color: var(--secondary-color);
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        padding: 20px;
    }

    .center {
        text-align: center;
    }

    .btn-primary {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
    }

    .btn-primary:hover {
        background-color: #b99593;
        border-color: #b99593;
    }

    .btn-secondary {
        background-color: white;
        border-color: var(--accent-color);
        color: var(--accent-color);
    }

    .btn-secondary:hover {
        background-color: var(--accent-color);
        color: white;
    }

    /* Enhanced Upload Area */
    .upload-area {
        border: 3px dashed var(--accent-color);
        border-radius: 15px;
        padding: 40px;
        text-align: center;
        transition: all 0.3s ease;
        background: rgba(255, 255, 255, 0.1);
        cursor: pointer;
        margin-bottom: 20px;
    }

    .upload-area:hover {
        border-color: var(--primary-color);
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.02);
    }

    .upload-area.dragover {
        border-color: #28a745;
        background: rgba(40, 167, 69, 0.1);
    }

    .upload-label {
        background: linear-gradient(45deg, var(--accent-color), #d4a5a3);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        font-weight: 600;
        transition: all 0.3s ease;
        cursor: pointer;
        display: inline-block;
    }

    .upload-label:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    /* Result styles */
    .prediction-result {
        margin-top: 20px;
        padding: 20px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .result-section {
        margin-bottom: 20px;
        border-bottom: 1px solid #f0f0f0;
        padding-bottom: 15px;
    }

    .result-section:last-child {
        border-bottom: none;
    }

    .result-section h3 {
        font-size: 1.1rem;
        color: var(--primary-color);
        margin-bottom: 10px;
    }

    .result-row {
        display: flex;
        margin-bottom: 10px;
        align-items: center;
    }

    .result-label {
        width: 150px;
        font-weight: 600;
        color: #555;
    }

    .result-value {
        flex: 1;
    }

    .color-preview {
        display: inline-block;
        width: 50px;
        height: 50px;
        border-radius: 8px;
        border: 1px solid #ddd;
        margin-right: 15px;
        vertical-align: middle;
    }

    .color-info {
        display: inline-block;
        vertical-align: middle;
    }

    /* Google Colab Setup Card */
    .colab-setup-card {
        background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
        border-radius: 15px;
        padding: 25px;
        margin: 25px 0;
        color: white;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }

    .colab-setup-card h3 {
        color: white;
        margin-bottom: 15px;
    }

    .colab-url-input {
        width: 100%;
        padding: 12px 15px;
        border: none;
        border-radius: 25px;
        margin: 10px 0;
        font-size: 16px;
    }

    .connect-btn {
        background: white;
        color: #4285f4;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        font-weight: 600;
        font-size: 16px;
        transition: all 0.3s ease;
        margin: 10px;
    }

    .connect-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }

    .connection-status {
        margin-top: 15px;
        padding: 15px;
        border-radius: 10px;
        display: none;
    }

    .connection-status.success {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .connection-status.error {
        background: rgba(220, 53, 69, 0.2);
        border: 1px solid rgba(220, 53, 69, 0.3);
    }

    /* 3D Model Generation Section */
    .model-generation-section {
        background: linear-gradient(135deg, var(--accent-color) 0%, #d4a5a3 100%);
        border-radius: 15px;
        padding: 25px;
        margin: 25px 0;
        color: white;
        text-align: center;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        display: none;
    }

    .generate-3d-btn {
        background: linear-gradient(45deg, var(--primary-color), #34495e);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        font-weight: 600;
        font-size: 16px;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        margin: 10px;
    }

    .generate-3d-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }

    .generate-3d-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }

    .generation-progress {
        margin: 20px 0;
        display: none;
    }

    .progress-container {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        height: 8px;
        overflow: hidden;
        margin: 15px 0;
    }

    .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--primary-color), #34495e);
        border-radius: 15px;
        width: 0%;
        transition: width 0.5s ease;
        animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
        0% { opacity: 1; }
        50% { opacity: 0.7; }
        100% { opacity: 1; }
    }

    .generation-status {
        font-weight: 600;
        margin: 10px 0;
        color: white;
    }

    /* Model Preview Card */
    .model-preview-card {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin: 20px 0;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        display: none;
        transform: translateY(20px);
        opacity: 0;
        transition: all 0.5s ease;
    }

    .model-preview-card.visible {
        display: block;
        transform: translateY(0);
        opacity: 1;
    }

    .model-info {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
    }

    .model-thumbnail {
        width: 60px;
        height: 60px;
        background: linear-gradient(45deg, var(--accent-color), #d4a5a3);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 15px;
        color: white;
        font-size: 24px;
    }

    .model-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
    }

    .model-actions .btn {
        flex: 1;
        min-width: 120px;
        border-radius: 20px;
        padding: 8px 16px;
        margin: 5px;
    }

    /* Enhanced 3D Viewer Modal - CLEAN WHITE THEME */
    .modal-xl {
        max-width: 90vw;
    }

    .simple-viewer-container {
        width: 100%;
        height: 70vh;
        position: relative;
        background: #ffffff !important; /* Pure white */
        border-radius: 0;
        overflow: hidden;
        border: 1px solid #e0e0e0;
    }

    .simple-viewer-header {
        background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%) !important;
        color: #333 !important;
        padding: 10px 20px;
        text-align: center;
        font-weight: 500;
        border-bottom: 1px solid #e0e0e0;
        font-size: 14px;
    }

    #threejs-viewer-container {
        width: 100%;
        height: calc(100% - 45px);
        position: absolute;
        top: 45px;
        left: 0;
        background: #ffffff !important;
    }

    /* Clean white controls styling */
    .simple-viewer-controls {
        position: absolute;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        background: rgba(255, 255, 255, 0.95);
        padding: 8px 16px;
        border-radius: 25px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
        border: 1px solid #e0e0e0;
        max-width: 90%;
        justify-content: center;
    }

    .simple-control-btn {
        background: #ffffff;
        border: 1px solid #e0e0e0;
        color: #333;
        padding: 6px 12px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 11px;
        transition: all 0.2s ease;
        white-space: nowrap;
        font-weight: 500;
    }

    .simple-control-btn:hover {
        background: #f8f9fa;
        border-color: #ccc;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .simple-control-btn:active {
        transform: translateY(0);
    }

    /* Loader styles */
    .loader {
        display: inline-block;
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid var(--accent-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 20px auto;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Toast Notification */
    .toast-notification {
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 350px;
        background: white;
        border-radius: 15px;
        padding: 15px 20px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        transform: translateX(100%);
        opacity: 0;
        transition: all 0.3s ease;
    }

    .toast-notification.show {
        transform: translateX(0);
        opacity: 1;
    }

    .toast-notification.success {
        border-left: 4px solid #28a745;
    }

    .toast-notification.error {
        border-left: 4px solid #dc3545;
    }

    .toast-notification.warning {
        border-left: 4px solid #ffc107;
    }

    .toast-notification.info {
        border-left: 4px solid #17a2b8;
    }

    .toast-content {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .toast-icon {
        font-size: 20px;
    }

    .toast-text {
        flex: 1;
    }

    .toast-title {
        font-weight: 600;
        margin-bottom: 2px;
    }

    .toast-close {
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        opacity: 0.7;
        padding: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .toast-close:hover {
        opacity: 1;
    }

    /* Colab Instructions */
    .colab-instructions {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 15px;
        margin-top: 15px;
    }

    .colab-step {
        margin-bottom: 10px;
        font-size: 14px;
    }

    .colab-step strong {
        color: #fff;
    }

    /* Quick View Button */
    .quick-view-floating {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 1000;
        animation: fadeInBounce 0.8s ease-out;
        display: none;
    }

    @keyframes fadeInBounce {
        0% {
            opacity: 0;
            transform: translateY(50px) scale(0.8);
        }
        50% {
            opacity: 1;
            transform: translateY(-10px) scale(1.1);
        }
        100% {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    .quick-view-floating .btn {
        position: relative;
        border-radius: 25px;
        padding: 15px 25px;
        font-size: 16px;
        font-weight: 600;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        border: none;
        background: linear-gradient(135deg, var(--accent-color) 0%, #d4a5a3 100%);
        color: white;
        transition: all 0.3s ease;
    }

    .quick-view-floating .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(0, 0, 0, 0.3);
    }

    /* Loading overlay for white background */
    .viewer-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95) !important;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 10;
        color: #333 !important;
    }

    .viewer-loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #f0f0f0;
        border-top: 3px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
    }

    /* Modal styling for clean look */
    .modal-content {
        border: none;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .modal-header {
        background: #ffffff;
        border-bottom: 1px solid #e0e0e0;
        padding: 15px 20px;
    }

    .modal-footer {
        background: #ffffff;
        border-top: 1px solid #e0e0e0;
        padding: 15px 20px;
    }

    .modal-title {
        color: #333;
        font-weight: 500;
        font-size: 16px;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .upload-area {
            padding: 25px 15px;
        }

        .model-actions {
            flex-direction: column;
        }

        .model-actions .btn {
            width: 100%;
            margin-bottom: 8px;
        }

        .quick-view-floating {
            bottom: 20px;
            right: 20px;
        }

        .quick-view-floating .btn {
            padding: 12px 20px;
            font-size: 14px;
        }

        .modal-xl {
            max-width: 95vw;
        }

        .simple-viewer-container {
            height: 50vh !important;
        }

        .simple-viewer-controls {
            bottom: 5px;
            padding: 6px;
            gap: 4px;
        }

        .simple-control-btn {
            padding: 5px 8px;
            font-size: 10px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <!-- Google Colab Setup Card -->
    <div class="colab-setup-card" id="colab-setup-card">
        <h3><i class="fab fa-google"></i> Google Colab 3D Generation</h3>
        <p>Connect to your Google Colab notebook to generate 3D models with free GPU power!</p>

        <div class="colab-url-section">
            <input type="url"
                   class="colab-url-input"
                   id="colab-url-input"
                   placeholder="https://your-ngrok-url.ngrok.io"
                   value="https://f606-34-72-94-244.ngrok-free.app/">
            <button class="connect-btn" onclick="connectToColab()" id="connect-colab-btn">
                <i class="fas fa-plug"></i> Connect to Colab
            </button>
        </div>

        <div class="connection-status" id="colab-connection-status">
            <!-- Connection status will be shown here -->
        </div>

        <div class="colab-instructions">
            <div class="colab-step">
                <strong>Quick Setup:</strong>
                1. Run your Colab TripoSR notebook
                2. Copy the ngrok URL
                3. Paste it above and click Connect
            </div>
        </div>
    </div>

    <!-- Main Upload Section -->
    <div class="card">
        <h1 class="center">
            <i class="fas fa-tshirt"></i> Add clothes to your wardrobe
        </h1>

        <!-- Enhanced Upload Area with Drag & Drop -->
        <div class="upload-area" id="upload-area">
            <div class="upload-content">
                <i class="fas fa-cloud-upload-alt fa-3x mb-3" style="color: var(--accent-color);"></i>
                <h4>Drag & Drop or Click to Upload</h4>
                <p class="text-muted">Support for PNG, JPG, JPEG files</p>
                <label for="imageUpload" class="upload-label">
                    <i class="fas fa-camera"></i> Choose Image
                </label>
                <input type="file" name="file" id="imageUpload" accept=".png, .jpg, .jpeg" style="display: none;">
            </div>
        </div>

        <div class="image-section" style="display:none;">
            <div class="img-preview text-center">
                <div id="imagePreview"></div>
            </div>
            <div class="text-center mt-3">
                <button type="button" class="btn btn-primary btn-lg" id="btn-predict">
                    <i class="fas fa-magic"></i> Analyze & Save to Wardrobe
                </button>
            </div>
        </div>
    </div>

    <!-- Analysis Results -->
    <div class="card">
        <h2><i class="fas fa-chart-line"></i> Analysis Results</h2>
        <div class="d-flex justify-content-center mb-3">
            <div class="loader" id="loading-spinner" style="display:none;"></div>
        </div>
        <div id="result"></div>

        <!-- 3D Model Generation Section -->
        <div id="model-generation-section" class="model-generation-section">
            <h3><i class="fas fa-cube"></i> AI-Powered 3D Model Generation</h3>
            <p>Transform your 2D clothing image into a stunning 3D model using Google Colab GPU</p>

            <button id="generate-3d-model-btn" class="generate-3d-btn">
                <i class="fab fa-google"></i> Generate 3D Model with Colab
            </button>

            <div class="generation-progress" id="generation-progress">
                <div class="generation-status" id="generation-status">Preparing...</div>
                <div class="progress-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <small>Using Google Colab GPU - This may take 2-4 minutes...</small>
            </div>

            <!-- Model Preview Card -->
            <div id="model-preview-card" class="model-preview-card">
                <div class="model-info">
                    <div class="model-thumbnail">
                        <i class="fas fa-cube"></i>
                    </div>
                    <div>
                        <h4>3D Model Generated Successfully!</h4>
                        <p class="text-muted">Your clothing item has been converted to a 3D model using Colab GPU</p>
                        <span class="badge" style="background-color: #4285f4; color: white; padding: 4px 8px; border-radius: 10px; font-size: 12px;">
                            <i class="fab fa-google"></i> Colab Generated
                        </span>
                    </div>
                </div>
                <div class="model-actions">
                    <button id="view-3d-model-btn" class="btn btn-primary">
                        <i class="fas fa-eye"></i> View in 3D
                    </button>
                    <button id="download-model-btn" class="btn btn-secondary">
                        <i class="fas fa-download"></i> Download OBJ
                    </button>
                    <button id="save-to-wardrobe-btn" class="btn btn-success">
                        <i class="fas fa-save"></i> Save to Wardrobe
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Quick View Button -->
<div id="quick-view-button" class="quick-view-floating">
    <button class="btn btn-primary btn-lg" onclick="view3DModel()" title="View 3D Model">
        <i class="fas fa-cube"></i>
        <span class="btn-text">View 3D Model</span>
    </button>
</div>

<!-- Toast Notification Template -->
<div id="toast-template" class="toast-notification" style="display: none;">
    <div class="toast-content">
        <div class="toast-icon">
            <i class="fas fa-check-circle"></i>
        </div>
        <div class="toast-text">
            <div class="toast-title"></div>
            <div class="toast-message"></div>
        </div>
        <button class="toast-close" onclick="hideToast(this.closest('.toast-notification'))">√ó</button>
    </div>
</div>

<!-- Enhanced 3D Viewer Modal with Clean White Background -->
<div class="modal fade" id="simple3DModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-cube"></i> ‚ú® Clean 3D Model Viewer - Clothing Optimized
                </h5>
                <button type="button" class="close" onclick="closeModal()">
                    <span>&times;</span>
                </button>
            </div>
            <div class="modal-body p-0">
                <div class="simple-viewer-container">
                    <div class="simple-viewer-header">
                        <div>Your 3D Clothing Model - Clean White Background</div>
                        <small>üñ±Ô∏è Left Click: Rotate | üñ±Ô∏è Right Click: Pan | üñ±Ô∏è Scroll: Zoom | Optimized for Clothing</small>
                    </div>

                    <!-- Three.js will render here -->
                    <div id="threejs-viewer-container"></div>

                    <div class="simple-viewer-controls">
                        <!-- Basic Controls -->
                        <button class="simple-control-btn" onclick="resetView()" title="Reset to optimal clothing view">
                            üè† Reset
                        </button>
                        <button class="simple-control-btn" onclick="toggleWireframe()" title="Toggle wireframe mode">
                            üìê Wire
                        </button>
                        <button class="simple-control-btn" onclick="toggleAutoRotate()" title="Toggle auto rotation">
                            üîÑ Rotate
                        </button>

                        <!-- Clothing-Specific View Controls -->
                        <button class="simple-control-btn" onclick="setClothingView('front')" title="Front view">
                            üëï Front
                        </button>
                        <button class="simple-control-btn" onclick="setClothingView('back')" title="Back view">
                            üîÑ Back
                        </button>
                        <button class="simple-control-btn" onclick="setClothingView('side')" title="Side view">
                            üëà Side
                        </button>
                        <button class="simple-control-btn" onclick="setClothingView('detail')" title="Detail view">
                            üîç Detail
                        </button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <div class="mr-auto">
                    <small class="text-muted">
                        <i class="fab fa-google"></i> Generated with Colab GPU ‚Ä¢ <i class="fas fa-cube"></i> Three.js Powered ‚Ä¢ ‚ú® Clean White Background
                    </small>
                </div>
                <button type="button" class="btn btn-secondary" onclick="closeModal()">
                    <i class="fas fa-times"></i> Close
                </button>
                <button type="button" class="btn btn-primary" onclick="downloadModel()">
                    <i class="fas fa-download"></i> Download OBJ
                </button>
                <button type="button" class="btn btn-success" onclick="saveToWardrobe()">
                    <i class="fas fa-save"></i> Save to Wardrobe
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Three.js with Known Working CDN URLs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three-orbitcontrols@2.110.3/OrbitControls.js"></script>

<!-- Bootstrap and jQuery -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.0/js/bootstrap.min.js"></script>

<script>
console.log('üéØ Starting ENHANCED 3D Wardrobe System with Clean White Background & Color Support...');

// ENHANCED OBJ LOADER WITH COLOR SUPPORT
class BulletproofOBJLoader {
    constructor(manager) {
        this.manager = manager || new THREE.LoadingManager();
    }

    load(url, onLoad, onProgress, onError) {
        const loader = new THREE.FileLoader(this.manager);
        loader.setResponseType('text');

        loader.load(url, (text) => {
            try {
                const object = this.parse(text);
                if (onLoad) onLoad(object);
            } catch (error) {
                console.error('üî• OBJ Parse Error:', error);
                if (onError) onError(error);
            }
        }, onProgress, onError);
    }

    parse(text) {
        console.log('üéØ Parsing OBJ with color support...');

        const vertices = [];
        const normals = [];
        const uvs = [];
        const vertexColors = []; // Store vertex colors
        const faces = [];

        const lines = text.split('\n');
        console.log(`üìä Processing ${lines.length} lines...`);

        let colorCount = 0;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            if (line.length === 0 || line.charAt(0) === '#') continue;

            const parts = line.split(/\s+/);
            const type = parts[0];

            switch (type) {
                case 'v':
                    // Parse vertices: v x y z [r g b]
                    vertices.push(
                        parseFloat(parts[1]) || 0,
                        parseFloat(parts[2]) || 0,
                        parseFloat(parts[3]) || 0
                    );

                    // Check for color data (RGB values after XYZ)
                    if (parts.length >= 7) {
                        const r = parseFloat(parts[4]) || 0.8;
                        const g = parseFloat(parts[5]) || 0.8;
                        const b = parseFloat(parts[6]) || 0.8;

                        vertexColors.push(r, g, b);
                        colorCount++;

                        if (colorCount <= 5) { // Log first few for debugging
                            console.log(`üé® Vertex ${Math.floor(vertices.length/3)}: color(${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)})`);
                        }
                    } else {
                        // Default gray if no color
                        vertexColors.push(0.8, 0.8, 0.8);
                    }
                    break;

                case 'vn':
                    normals.push(
                        parseFloat(parts[1]) || 0,
                        parseFloat(parts[2]) || 0,
                        parseFloat(parts[3]) || 0
                    );
                    break;

                case 'vt':
                    uvs.push(
                        parseFloat(parts[1]) || 0,
                        parseFloat(parts[2]) || 0
                    );
                    break;

                case 'f':
                    this.parseFace(parts.slice(1), faces);
                    break;
            }
        }

        console.log(`‚úÖ Parsed: ${vertices.length/3} vertices, ${faces.length} faces`);
        console.log(`üé® Found ${colorCount} vertices with color data`);

        return this.buildGeometry(vertices, normals, uvs, faces, vertexColors);
    }

    parseFace(faceData, faces) {
        const face = [];

        for (let i = 0; i < faceData.length; i++) {
            const vertex = faceData[i];
            const indices = vertex.split('/');

            face.push({
                vertex: indices[0] ? parseInt(indices[0]) - 1 : 0,
                uv: indices[1] ? parseInt(indices[1]) - 1 : null,
                normal: indices[2] ? parseInt(indices[2]) - 1 : null
            });
        }

        // Triangulate face (convert quads to triangles)
        for (let i = 1; i < face.length - 1; i++) {
            faces.push([face[0], face[i], face[i + 1]]);
        }
    }

    buildGeometry(vertices, normals, uvs, faces, vertexColors = []) {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const normalsArray = [];
        const uvsArray = [];
        const colorsArray = [];

        const hasColors = vertexColors.length > 0;
        console.log(`üé® Building geometry - Has colors: ${hasColors}, Color count: ${vertexColors.length/3}`);

        for (let i = 0; i < faces.length; i++) {
            const face = faces[i];

            for (let j = 0; j < 3; j++) {
                const vertexIndex = face[j].vertex;
                const normalIndex = face[j].normal;
                const uvIndex = face[j].uv;

                // Positions
                if (vertexIndex >= 0 && vertexIndex < vertices.length / 3) {
                    positions.push(
                        vertices[vertexIndex * 3] || 0,
                        vertices[vertexIndex * 3 + 1] || 0,
                        vertices[vertexIndex * 3 + 2] || 0
                    );
                } else {
                    positions.push(0, 0, 0);
                }

                // Normals
                if (normalIndex !== null && normalIndex >= 0 && normalIndex < normals.length / 3) {
                    normalsArray.push(
                        normals[normalIndex * 3] || 0,
                        normals[normalIndex * 3 + 1] || 1,
                        normals[normalIndex * 3 + 2] || 0
                    );
                } else {
                    normalsArray.push(0, 1, 0);
                }

                // UVs
                if (uvIndex !== null && uvIndex >= 0 && uvIndex < uvs.length / 2) {
                    uvsArray.push(
                        uvs[uvIndex * 2] || 0,
                        uvs[uvIndex * 2 + 1] || 0
                    );
                } else {
                    uvsArray.push(0, 0);
                }

                // Colors
                if (hasColors && vertexIndex >= 0 && vertexIndex < vertexColors.length / 3) {
                    colorsArray.push(
                        vertexColors[vertexIndex * 3] || 0.8,
                        vertexColors[vertexIndex * 3 + 1] || 0.8,
                        vertexColors[vertexIndex * 3 + 2] || 0.8
                    );
                } else {
                    colorsArray.push(0.8, 0.8, 0.8);
                }
            }
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normalsArray, 3));
        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvsArray, 2));

        // Add color attribute if we have colors
        if (hasColors) {
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsArray, 3));
            console.log('üé® ‚úÖ Added color attribute to geometry!');
        }

        // Compute normals if not provided
        if (normals.length === 0) {
            geometry.computeVertexNormals();
        }

        // Create material with color support
        const material = new THREE.MeshLambertMaterial({
            color: hasColors ? 0xffffff : 0xcccccc, // White if using vertex colors, gray otherwise
            vertexColors: hasColors, // Enable vertex colors if available
            side: THREE.DoubleSide,
            transparent: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        const group = new THREE.Group();
        group.add(mesh);

        if (hasColors) {
            console.log('üéâ ‚úÖ COLORED OBJ geometry built successfully!');
        } else {
            console.log('üéØ Standard OBJ geometry built (no colors found)');
        }

        return group;
    }
}

// CLEAN WHITE BACKGROUND CLOTHING VIEWER
class CleanWhiteClothingViewer {
    constructor(container) {
        this.container = container;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.model = null;
        this.clothingType = 'unknown';

        this.init();
    }

    init() {
        console.log('üöÄ Initializing Clean White Clothing Viewer...');

        // Scene with pure white background
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xffffff); // Pure white

        // Camera setup optimized for clothing
        this.camera = new THREE.PerspectiveCamera(
            35, // Narrow FOV for clothing
            this.container.clientWidth / this.container.clientHeight,
            0.01,
            100
        );
        this.camera.position.set(0, 1, 3);

        // Renderer with white background
        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false,
            preserveDrawingBuffer: true
        });
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.setClearColor(0xffffff, 1.0); // White backup

        this.container.innerHTML = '';
        this.container.appendChild(this.renderer.domElement);

        // Controls optimized for clothing
        this.controls = createOrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 0.5; // Can get close to see fabric details
        this.controls.maxDistance = 8;

        // Limit vertical rotation for clothing
        this.controls.maxPolarAngle = Math.PI * 0.8;
        this.controls.minPolarAngle = Math.PI * 0.1;

        // White background lighting
        this.setupCleanWhiteLighting();
        this.animate();
        window.addEventListener('resize', () => this.onWindowResize());

        console.log('‚úÖ Clean White Clothing Viewer ready');
    }

    setupCleanWhiteLighting() {
        // Clear existing lights
        const lights = [];
        this.scene.traverse(child => {
            if (child.isLight) lights.push(child);
        });
        lights.forEach(light => this.scene.remove(light));

        // Studio white background lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambient);

        const key = new THREE.DirectionalLight(0xffffff, 0.8);
        key.position.set(3, 5, 4);
        key.castShadow = true;
        key.shadow.mapSize.setScalar(2048);
        key.shadow.radius = 4;
        key.shadow.blurSamples = 25;
        this.scene.add(key);

        const fill = new THREE.DirectionalLight(0xffffff, 0.4);
        fill.position.set(-2, 3, 2);
        this.scene.add(fill);

        const rim = new THREE.DirectionalLight(0xffffff, 0.2);
        rim.position.set(0, 2, -3);
        this.scene.add(rim);

        console.log('üí° Clean white studio lighting setup complete');
    }

    async loadOBJModel(objUrl) {
        try {
            console.log(`üîÑ Loading colored clothing model: ${objUrl}`);
            this.showLoadingState();

            const loader = new BulletproofOBJLoader();

            return new Promise((resolve, reject) => {
                loader.load(
                    objUrl,
                    (object) => {
                        console.log('‚úÖ Colored clothing model loaded successfully!');
                        this.processColoredClothingModel(object);
                        this.hideLoadingState();
                        resolve(object);
                    },
                    (progress) => {
                        if (progress.total > 0) {
                            const percent = Math.floor((progress.loaded / progress.total) * 100);
                            this.updateLoadingProgress(percent);
                        }
                    },
                    (error) => {
                        console.error('‚ùå Error loading colored clothing model:', error);
                        this.hideLoadingState();
                        this.showErrorState('Failed to load colored clothing model');
                        reject(error);
                    }
                );
            });
        } catch (error) {
            console.error('‚ùå Error in loadOBJModel:', error);
            this.hideLoadingState();
            this.showErrorState('Failed to initialize colored clothing model loader');
            throw error;
        }
    }

    processColoredClothingModel(object) {
        // Remove previous model
        if (this.model) {
            this.scene.remove(this.model);
        }

        this.model = object;
        this.detectClothingType();

        // Enhanced processing for colored clothing models
        this.model.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;

                // Optimize material for clothing with colors
                if (child.material) {
                    child.material.side = THREE.DoubleSide; // Important for fabric
                    child.material.needsUpdate = true;

                    // Ensure vertex colors are enabled if available
                    if (child.geometry.attributes.color) {
                        child.material.vertexColors = true;
                        console.log('üé® Enabled vertex colors for clothing mesh');
                    }

                    // Add slight roughness for fabric appearance
                    if (child.material.roughness !== undefined) {
                        child.material.roughness = 0.8;
                    }
                }

                console.log(`üé® Processed clothing mesh: ${child.name}, has colors: ${!!child.geometry.attributes.color}`);
            }
        });

        this.scene.add(this.model);
        this.fitCameraToClothing();

        console.log(`üéØ Colored clothing model processed (type: ${this.clothingType})`);
    }

    detectClothingType() {
        // Analyze model dimensions to guess clothing type
        const box = new THREE.Box3().setFromObject(this.model);
        const size = box.getSize(new THREE.Vector3());

        const width = size.x;
        const height = size.y;
        const depth = size.z;

        console.log(`üìè Clothing dimensions: ${width.toFixed(2)} x ${height.toFixed(2)} x ${depth.toFixed(2)}`);

        // Simple heuristics for clothing type detection
        if (height > width * 1.5 && height > depth * 2) {
            this.clothingType = 'dress_or_long';
        } else if (width > height && depth < width * 0.3) {
            this.clothingType = 'pants';
        } else if (height > width && width > depth) {
            this.clothingType = 'shirt_or_top';
        } else if (width > height * 1.2) {
            this.clothingType = 'jacket_or_wide';
        } else {
            this.clothingType = 'general_clothing';
        }

        console.log(`üëï Detected clothing type: ${this.clothingType}`);
    }

    fitCameraToClothing() {
        if (!this.model) return;

        const box = new THREE.Box3().setFromObject(this.model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        // Calculate optimal distance based on clothing type
        let cameraDistance;
        let cameraHeight;
        let cameraAngle;

        switch (this.clothingType) {
            case 'dress_or_long':
                cameraDistance = Math.max(size.y * 0.8, 2.5);
                cameraHeight = center.y;
                cameraAngle = 0.2;
                break;

            case 'shirt_or_top':
                cameraDistance = Math.max(size.x * 1.2, 2.0);
                cameraHeight = center.y + size.y * 0.1;
                cameraAngle = 0.3;
                break;

            case 'pants':
                cameraDistance = Math.max(size.y * 0.9, 2.2);
                cameraHeight = center.y - size.y * 0.1;
                cameraAngle = 0.1;
                break;

            case 'jacket_or_wide':
                cameraDistance = Math.max(size.x * 1.1, 2.3);
                cameraHeight = center.y + size.y * 0.05;
                cameraAngle = 0.25;
                break;

            default:
                cameraDistance = Math.max(Math.max(size.x, size.y, size.z) * 1.2, 2.0);
                cameraHeight = center.y;
                cameraAngle = 0.3;
        }

        // Ensure reasonable bounds
        cameraDistance = Math.max(1.5, Math.min(6, cameraDistance));

        // Position camera
        this.camera.position.set(
            cameraDistance * Math.sin(cameraAngle),
            cameraHeight,
            cameraDistance * Math.cos(cameraAngle)
        );

        // Update controls
        this.controls.target.copy(center);
        this.controls.update();

        console.log(`üì∏ Camera positioned for ${this.clothingType}: distance=${cameraDistance.toFixed(2)}, height=${cameraHeight.toFixed(2)}`);
    }

    // Preset camera positions for different clothing views
    setClothingView(viewType) {
        if (!this.model) return;

        const box = new THREE.Box3().setFromObject(this.model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);

        let position, target;

        switch (viewType) {
            case 'front':
                position = new THREE.Vector3(0, center.y, maxDim * 1.5);
                target = center.clone();
                break;

            case 'back':
                position = new THREE.Vector3(0, center.y, -maxDim * 1.5);
                target = center.clone();
                break;

            case 'side':
                position = new THREE.Vector3(maxDim * 1.5, center.y, 0);
                target = center.clone();
                break;

            case 'detail':
                position = new THREE.Vector3(
                    maxDim * 0.3,
                    center.y + size.y * 0.2,
                    maxDim * 0.8
                );
                target = new THREE.Vector3(center.x, center.y + size.y * 0.1, center.z);
                break;

            default: // 'overview'
                position = new THREE.Vector3(
                    maxDim * 0.8,
                    center.y + maxDim * 0.3,
                    maxDim * 1.2
                );
                target = center.clone();
        }

        // Smooth camera transition
        this.animateCameraTo(position, target);
    }

    animateCameraTo(targetPosition, targetLookAt, duration = 1000) {
        const startPosition = this.camera.position.clone();
        const startTarget = this.controls.target.clone();
        const startTime = Date.now();

        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Smooth easing
            const eased = progress * progress * (3 - 2 * progress);

            // Interpolate position
            this.camera.position.lerpVectors(startPosition, targetPosition, eased);
            this.controls.target.lerpVectors(startTarget, targetLookAt, eased);

            this.controls.update();

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        animate();
    }

    showLoadingState() {
        let loadingDiv = this.container.querySelector('.viewer-loading-overlay');
        if (!loadingDiv) {
            loadingDiv = document.createElement('div');
            loadingDiv.className = 'viewer-loading-overlay';
            loadingDiv.innerHTML = `
                <div class="viewer-loading-spinner"></div>
                <div style="font-size: 18px; font-weight: 600; color: #333;">Loading Colored 3D Model...</div>
                <div class="loading-progress" style="margin-top: 10px; font-size: 14px; opacity: 0.8; color: #666;">0%</div>
            `;
            this.container.appendChild(loadingDiv);
        }
        loadingDiv.style.display = 'flex';
    }

    updateLoadingProgress(percent) {
        const progressDiv = this.container.querySelector('.loading-progress');
        if (progressDiv) {
            progressDiv.textContent = `${percent}%`;
        }
    }

    hideLoadingState() {
        const loadingDiv = this.container.querySelector('.viewer-loading-overlay');
        if (loadingDiv) {
            loadingDiv.style.display = 'none';
        }
    }

    showErrorState(message) {
        this.hideLoadingState();
        const errorDiv = document.createElement('div');
        errorDiv.className = 'viewer-loading-overlay';
        errorDiv.style.background = 'rgba(220, 53, 69, 0.1)';
        errorDiv.innerHTML = `
            <div style="font-size: 48px; margin-bottom: 15px;">‚ö†Ô∏è</div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px; color: #dc3545;">3D Viewer Error</div>
            <div style="font-size: 14px; color: #dc3545;">${message}</div>
        `;
        this.container.appendChild(errorDiv);
    }

    toggleAutoRotate() {
        this.controls.autoRotate = !this.controls.autoRotate;
        return this.controls.autoRotate;
    }

    resetCamera() {
        this.fitCameraToClothing();
    }

    toggleWireframe() {
        if (!this.model) return false;
        let wireframeEnabled = false;
        this.model.traverse((child) => {
            if (child.isMesh && child.material) {
                child.material.wireframe = !child.material.wireframe;
                wireframeEnabled = child.material.wireframe;
            }
        });
        return wireframeEnabled;
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        if (this.controls) this.controls.update();
        if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    }

    onWindowResize() {
        if (!this.camera || !this.renderer) return;
        this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    }

    dispose() {
        if (this.renderer) this.renderer.dispose();
        if (this.controls) this.controls.dispose();
        window.removeEventListener('resize', this.onWindowResize);
        console.log('üóëÔ∏è Clean white clothing viewer disposed');
    }
}

// Global variables
let currentUploadedFile = null;
let currentItemData = null;
let generatedModelData = null;
let currentGenerationTaskId = null;
let colabConnected = false;
let wardrobeViewer = null;

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log('üì± DOM loaded, initializing enhanced wardrobe app...');
    initializeApp();

    const savedUrl = document.getElementById('colab-url-input').value;
    if (savedUrl) {
        console.log('üîó Auto-connecting to saved Colab URL...');
        connectToColab();
    }
});

function initializeApp() {
    console.log('üöÄ Initializing enhanced wardrobe app...');
    setupEventListeners();
    setupDragAndDrop();
    console.log('‚úÖ App initialization complete');
}

// WORKING ORBITCONTROLS FUNCTION
function createOrbitControls(camera, domElement) {
    const controls = {
        camera: camera,
        domElement: domElement,
        target: new THREE.Vector3(0, 0, 0),
        minDistance: 1,
        maxDistance: 20,
        enableDamping: true,
        dampingFactor: 0.05,
        autoRotate: false,
        autoRotateSpeed: 2,

        spherical: new THREE.Spherical(),
        sphericalDelta: new THREE.Spherical(),

        STATE: { NONE: -1, ROTATE: 0, PAN: 2 },
        state: -1,

        rotateStart: new THREE.Vector2(),
        rotateEnd: new THREE.Vector2(),

        update: function() {
            if (this.autoRotate && this.state === this.STATE.NONE) {
                this.sphericalDelta.theta += (2 * Math.PI / 60 / 60) * this.autoRotateSpeed;
            }

            this.spherical.theta += this.sphericalDelta.theta;
            this.spherical.phi += this.sphericalDelta.phi;
            this.spherical.radius *= this.scale || 1;

            this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
            this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));

            const offset = new THREE.Vector3().setFromSpherical(this.spherical);
            this.camera.position.copy(this.target).add(offset);
            this.camera.lookAt(this.target);

            if (this.enableDamping) {
                this.sphericalDelta.theta *= (1 - this.dampingFactor);
                this.sphericalDelta.phi *= (1 - this.dampingFactor);
            }
        },

        dispose: function() {
            this.domElement.removeEventListener('mousedown', this.onMouseDown);
            this.domElement.removeEventListener('wheel', this.onMouseWheel);
        }
    };

    controls.onMouseDown = function(event) {
        event.preventDefault();
        if (event.button === 0) {
            this.state = this.STATE.ROTATE;
            this.rotateStart.set(event.clientX, event.clientY);
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onMouseUp);
        }
    }.bind(controls);

    controls.onMouseMove = function(event) {
        if (this.state === this.STATE.ROTATE) {
            this.rotateEnd.set(event.clientX, event.clientY);
            const delta = new THREE.Vector2().subVectors(this.rotateEnd, this.rotateStart);

            this.sphericalDelta.theta -= delta.x * 0.01;
            this.sphericalDelta.phi -= delta.y * 0.01;

            this.rotateStart.copy(this.rotateEnd);
        }
    }.bind(controls);

    controls.onMouseUp = function() {
        this.state = this.STATE.NONE;
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }.bind(controls);

    controls.onMouseWheel = function(event) {
        event.preventDefault();
        const scale = event.deltaY > 0 ? 1.1 : 0.9;
        controls.scale = (controls.scale || 1) * scale;
    };

    // Add event listeners
    controls.domElement.addEventListener('mousedown', controls.onMouseDown);
    controls.domElement.addEventListener('wheel', controls.onMouseWheel);
    controls.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

    // Initialize
    const offset = new THREE.Vector3().subVectors(camera.position, controls.target);
    controls.spherical.setFromVector3(offset);
    controls.scale = 1;

    return controls;
}

function setupEventListeners() {
    // Upload functionality
    document.getElementById('imageUpload').addEventListener('change', handleFileSelect);
    document.getElementById('btn-predict').addEventListener('click', analyzeImage);

    // 3D model generation
    document.getElementById('generate-3d-model-btn').addEventListener('click', generate3DModel);
    document.getElementById('view-3d-model-btn').addEventListener('click', view3DModel);
    document.getElementById('download-model-btn').addEventListener('click', downloadModel);
    document.getElementById('save-to-wardrobe-btn').addEventListener('click', saveToWardrobe);

    console.log('üéØ Event listeners attached');
}

function setupDragAndDrop() {
    const uploadArea = document.getElementById('upload-area');

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
    });

    ['dragenter', 'dragover'].forEach(eventName => {
        uploadArea.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, unhighlight, false);
    });

    uploadArea.addEventListener('drop', handleDrop, false);

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    function highlight() {
        uploadArea.classList.add('dragover');
    }

    function unhighlight() {
        uploadArea.classList.remove('dragover');
    }

    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        handleFiles(files);
    }
}

function handleFiles(files) {
    if (files.length > 0) {
        const file = files[0];
        if (file.type.startsWith('image/')) {
            currentUploadedFile = file;
            displayImagePreview(file);
        } else {
            showToast('Please select a valid image file (PNG, JPG, JPEG)', 'error');
        }
    }
}

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        currentUploadedFile = file;
        displayImagePreview(file);
    }
}

function displayImagePreview(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const imagePreview = document.getElementById('imagePreview');
        imagePreview.innerHTML = `
            <img src="${e.target.result}" alt="Preview" class="img-fluid" style="max-height: 300px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
        `;
        document.querySelector('.image-section').style.display = 'block';
    };
    reader.readAsDataURL(file);
}

// COLAB CONNECTION FUNCTIONS
function connectToColab() {
    const urlInput = document.getElementById('colab-url-input');
    const connectBtn = document.getElementById('connect-colab-btn');
    const colabUrl = urlInput.value.trim();

    if (!colabUrl) {
        showToast('Please enter a Colab API URL', 'warning');
        return;
    }

    connectBtn.disabled = true;
    connectBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Connecting...';

    fetch('/api/set-colab-url', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ colab_url: colabUrl })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast('‚úÖ Connected to Colab API successfully!', 'success');
            showColabConnectionStatus(true, 'Connected and ready for 3D generation');
            colabConnected = true;

            const generateBtn = document.getElementById('generate-3d-model-btn');
            generateBtn.disabled = false;
            generateBtn.innerHTML = '<i class="fab fa-google"></i> Generate 3D Model with Colab';
        } else {
            throw new Error(data.error || 'Failed to connect');
        }
    })
    .catch(error => {
        console.error('Error connecting to Colab:', error);
        showToast('‚ùå Failed to connect to Colab API', 'error');
        showColabConnectionStatus(false, error.message);
        colabConnected = false;
    })
    .finally(() => {
        connectBtn.disabled = false;
        connectBtn.innerHTML = '<i class="fas fa-plug"></i> Connect to Colab';
    });
}

function showColabConnectionStatus(success, message) {
    const statusDiv = document.getElementById('colab-connection-status');
    statusDiv.style.display = 'block';
    statusDiv.className = `connection-status ${success ? 'success' : 'error'}`;
    statusDiv.innerHTML = `
        <div class="d-flex align-items-center">
            <i class="fas fa-${success ? 'check-circle' : 'exclamation-triangle'} mr-2"></i>
            <span>${message}</span>
        </div>
    `;
}

// IMAGE ANALYSIS FUNCTION
function analyzeImage() {
    if (!currentUploadedFile) {
        showToast('Please select an image first', 'warning');
        return;
    }

    const loadingSpinner = document.getElementById('loading-spinner');
    const resultDiv = document.getElementById('result');
    const btnPredict = document.getElementById('btn-predict');

    loadingSpinner.style.display = 'block';
    btnPredict.disabled = true;
    btnPredict.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing...';
    resultDiv.innerHTML = '';

    const formData = new FormData();
    formData.append('file', currentUploadedFile);

    fetch('/wardrobe', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        loadingSpinner.style.display = 'none';
        btnPredict.disabled = false;
        btnPredict.innerHTML = '<i class="fas fa-magic"></i> Analyze & Save to Wardrobe';

        if (data.success) {
            currentItemData = data;
            console.log('üéØ Current item data with ID:', currentItemData);
            displayAnalysisResults(data);
            showModelGenerationSection();
            showToast('‚úÖ Image analyzed and saved to wardrobe!', 'success');
        } else {
            showToast(data.error || 'Analysis failed', 'error');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        loadingSpinner.style.display = 'none';
        btnPredict.disabled = false;
        btnPredict.innerHTML = '<i class="fas fa-magic"></i> Analyze & Save to Wardrobe';
        showToast('Error analyzing image', 'error');
    });
}

function displayAnalysisResults(data) {
    const resultDiv = document.getElementById('result');

    let resultHTML = `
        <div class="prediction-result">
            <div class="result-section">
                <h3><i class="fas fa-tag"></i> Clothing Classification</h3>
                <div class="result-row">
                    <div class="result-label">Category:</div>
                    <div class="result-value"><strong>${data.prediction}</strong></div>
                </div>
                <div class="result-row">
                    <div class="result-label">Confidence:</div>
                    <div class="result-value">${(data.confidence * 100).toFixed(1)}%</div>
                </div>
                <div class="result-row">
                    <div class="result-label">Item ID:</div>
                    <div class="result-value"><code>${data.item_id}</code></div>
                </div>
            </div>
    `;

    if (data.color) {
        const colorRGB = data.color.rgb || [128, 128, 128];
        resultHTML += `
            <div class="result-section">
                <h3><i class="fas fa-palette"></i> Color Analysis</h3>
                <div class="result-row">
                    <div class="result-label">Dominant Color:</div>
                    <div class="result-value">
                        <div class="color-preview" style="background-color: rgb(${colorRGB.join(',')});"></div>
                        <div class="color-info">
                            <strong>RGB: ${colorRGB.join(', ')}</strong><br>
                            <small>Coverage: ${(data.color.percentage * 100).toFixed(1)}%</small>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    resultHTML += '</div>';
    resultDiv.innerHTML = resultHTML;
}

function showModelGenerationSection() {
    const section = document.getElementById('model-generation-section');
    section.style.display = 'block';
    section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// 3D MODEL GENERATION
function generate3DModel() {
    if (!currentUploadedFile) {
        showToast('Please upload an image first', 'warning');
        return;
    }

    if (!colabConnected) {
        showToast('Please connect to Colab first', 'warning');
        document.getElementById('colab-setup-card').scrollIntoView({ behavior: 'smooth' });
        return;
    }

    const generateBtn = document.getElementById('generate-3d-model-btn');
    const progressDiv = document.getElementById('generation-progress');
    const statusText = document.getElementById('generation-status');
    const progressBar = document.getElementById('progress-bar');

    generateBtn.disabled = true;
    generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating with Colab...';
    progressDiv.style.display = 'block';

    progressBar.style.width = '0%';
    statusText.textContent = 'Uploading to Colab GPU...';

    const formData = new FormData();
    formData.append('image', currentUploadedFile);

    console.log('üöÄ Starting 3D generation...');

    fetch('/api/generate-3d-model', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            currentGenerationTaskId = data.task_id;
            console.log('‚úÖ Generation started, task ID:', currentGenerationTaskId);
            showToast(`üöÄ 3D generation started with Colab GPU! ${data.estimated_time}`, 'info');
            startStatusPolling();
        } else {
            throw new Error(data.error || 'Failed to start generation');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        showToast(`‚ùå Error: ${error.message}`, 'error');
        resetGenerationUI();
    });
}

function startStatusPolling() {
    if (!currentGenerationTaskId) return;

    const statusText = document.getElementById('generation-status');
    const progressBar = document.getElementById('progress-bar');

    console.log('üîç Starting status polling for task:', currentGenerationTaskId);

    const pollStatus = () => {
        fetch(`/api/check-generation-status?task_id=${currentGenerationTaskId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusText.textContent = data.message;
                    progressBar.style.width = (data.progress * 100) + '%';

                    console.log(`üîÑ Status: ${data.status}, Progress: ${(data.progress * 100).toFixed(1)}%`);

                    if (data.status === 'completed') {
                        handleGenerationSuccess(data);
                    } else if (data.status === 'failed') {
                        handleGenerationFailure(data);
                    } else {
                        setTimeout(pollStatus, 3000);
                    }
                } else {
                    throw new Error(data.error || 'Status check failed');
                }
            })
            .catch(error => {
                console.error('Error checking status:', error);
                showToast(`‚ùå Error: ${error.message}`, 'error');
                resetGenerationUI();
            });
    };

    setTimeout(pollStatus, 2000);
}

function handleGenerationSuccess(data) {
    console.log('üéâ Generation completed with data:', data);

    generatedModelData = {
        model_path: data.model_path,
        local_path: data.local_path,
        file_size: data.file_size,
        file_format: data.file_format || 'OBJ',
        method: data.method || 'colab',
        completed_at: data.completed_at,
        task_id: currentGenerationTaskId
    };

    console.log('üíæ Stored model data:', generatedModelData);

    const progressDiv = document.getElementById('generation-progress');
    const previewCard = document.getElementById('model-preview-card');

    progressDiv.style.display = 'none';
    previewCard.classList.add('visible');

    resetGenerationUI();
    showToast('üéâ 3D model generated successfully with Colab!', 'success');
    showQuickViewButton();

    if (currentItemData && currentItemData.item_id) {
        console.log('üîÑ Auto-saving 3D model to database...');
        autoSave3DModel();
    }

    currentGenerationTaskId = null;
}

function handleGenerationFailure(data) {
    const errorMessage = data.error || data.message || 'Generation failed';
    console.error('‚ùå Generation failed:', errorMessage);
    showToast(`‚ùå Generation failed: ${errorMessage}`, 'error');
    resetGenerationUI();
    currentGenerationTaskId = null;
}

function resetGenerationUI() {
    const generateBtn = document.getElementById('generate-3d-model-btn');
    const progressDiv = document.getElementById('generation-progress');

    if (generateBtn) {
        generateBtn.disabled = false;
        generateBtn.innerHTML = '<i class="fab fa-google"></i> Generate 3D Model with Colab';
    }

    if (progressDiv) {
        progressDiv.style.display = 'none';
    }
}

function autoSave3DModel() {
    if (!generatedModelData || !currentItemData) {
        console.log('‚ùå Cannot auto-save: missing data');
        return;
    }

    const itemId = currentItemData.item_id || currentItemData._id || currentItemData.id;

    if (!itemId) {
        console.log('‚ùå No valid item ID found:', currentItemData);
        return;
    }

    console.log('üíæ Auto-saving 3D model for item:', itemId);

    fetch('/api/save-3d-model', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            item_id: itemId,
            model_path: generatedModelData.model_path,
            method: generatedModelData.method,
            file_format: generatedModelData.file_format,
            file_size: generatedModelData.file_size
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('‚úÖ 3D model auto-saved to database');
            showToast('‚úÖ 3D model automatically saved to wardrobe', 'success');

            currentItemData.has_3d_model = true;
            currentItemData.model_3d_path = generatedModelData.model_path;
        } else {
            console.log('‚ùå Auto-save failed:', data.error);
            showToast('‚ö†Ô∏è Model generated but not saved to wardrobe. Use Save button.', 'warning');
        }
    })
    .catch(error => {
        console.error('‚ùå Auto-save error:', error);
        showToast('‚ö†Ô∏è Model generated but auto-save failed. Use Save button.', 'warning');
    });
}

// ENHANCED VIEW 3D MODEL FUNCTION WITH CLEAN WHITE BACKGROUND
function view3DModel() {
    if (!generatedModelData) {
        showToast('No 3D model available', 'warning');
        return;
    }

    console.log('üéØ Opening clean white clothing 3D viewer with:', generatedModelData.model_path);

    $('#simple3DModal').modal('show');

    $('#simple3DModal').on('shown.bs.modal', function () {
        console.log('üì∫ Modal shown, initializing clean white clothing viewer...');
        initCleanWhiteClothingViewer();
    });

    $('#simple3DModal').on('hidden.bs.modal', function () {
        console.log('üóëÔ∏è Modal hidden, cleaning up viewer...');
        if (wardrobeViewer) {
            wardrobeViewer.dispose();
            wardrobeViewer = null;
        }
    });
}

function initCleanWhiteClothingViewer() {
    console.log('üéØ Initializing Clean White Clothing 3D Viewer...');

    const threejsContainer = document.getElementById('threejs-viewer-container');
    if (!threejsContainer) {
        console.error('‚ùå Viewer container not found!');
        return;
    }

    // Initialize the clean white clothing viewer
    wardrobeViewer = new CleanWhiteClothingViewer(threejsContainer);

    // Load the model
    if (generatedModelData && generatedModelData.model_path) {
        console.log(`üî• LOADING COLORED CLOTHING MODEL: ${generatedModelData.model_path}`);

        wardrobeViewer.loadOBJModel(generatedModelData.model_path)
            .then((result) => {
                console.log('üéâ SUCCESS! Colored clothing model loaded:', result);
                showToast('‚ú® 3D clothing model loaded with clean white background!', 'success');
            })
            .catch(error => {
                console.error('üí• FAILED to load colored clothing model:', error);
                showToast('‚ùå Failed to load 3D model', 'error');
            });
    } else {
        console.error('‚ùå No model path provided!');
        showToast('‚ùå No model data available', 'error');
    }

    // Update control functions with clothing viewer
    window.resetView = () => {
        if (wardrobeViewer) {
            wardrobeViewer.resetCamera();
            showToast('üè† View reset to optimal clothing angle', 'success');
        }
    };

    window.toggleWireframe = () => {
        if (wardrobeViewer) {
            const enabled = wardrobeViewer.toggleWireframe();
            showToast(`üìê Wireframe ${enabled ? 'ON' : 'OFF'}`, 'success');
        }
    };

    window.toggleAutoRotate = () => {
        if (wardrobeViewer) {
            const enabled = wardrobeViewer.toggleAutoRotate();
            showToast(`üîÑ Auto-rotate ${enabled ? 'ON' : 'OFF'}`, 'success');
        }
    };

    window.setClothingView = (viewType) => {
        if (wardrobeViewer && wardrobeViewer.setClothingView) {
            wardrobeViewer.setClothingView(viewType);
            showToast(`üì∏ ${viewType.charAt(0).toUpperCase() + viewType.slice(1)} view`, 'success');
        }
    };

    return wardrobeViewer;
}

// DOWNLOAD AND SAVE FUNCTIONS
function downloadModel() {
    if (!generatedModelData || !generatedModelData.model_path) {
        showToast('No 3D model available for download', 'warning');
        return;
    }

    console.log(`üì• Downloading model from: ${generatedModelData.model_path}`);

    try {
        const link = document.createElement('a');
        link.href = generatedModelData.model_path;

        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
        const extension = generatedModelData.file_format ? generatedModelData.file_format.toLowerCase() : 'obj';
        link.download = `wardrobe_3d_model_${timestamp}.${extension}`;

        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        showToast(`üì• 3D model download started (${generatedModelData.file_format || 'OBJ'} format)`, 'success');
        console.log('‚úÖ Download initiated');
    } catch (error) {
        console.error('‚ùå Download error:', error);

        try {
            window.open(generatedModelData.model_path, '_blank');
            showToast('üì• Opening model file in new tab', 'success');
        } catch (error2) {
            console.error('‚ùå Fallback download failed:', error2);
            showToast(`‚ùå Download failed. Model path: ${generatedModelData.model_path}`, 'error');
        }
    }
}

function saveToWardrobe() {
    if (!currentItemData || !generatedModelData) {
        showToast('No model data to save', 'warning');
        return;
    }

    const itemId = currentItemData.item_id || currentItemData._id || currentItemData.id;

    if (!itemId) {
        showToast('No valid item ID found', 'warning');
        console.log('‚ùå Current item data:', currentItemData);
        return;
    }

    const saveBtn = document.getElementById('save-to-wardrobe-btn');
    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
    }

    console.log('üíæ Manually saving 3D model to wardrobe...');

    fetch('/api/save-3d-model', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            item_id: itemId,
            model_path: generatedModelData.model_path,
            method: generatedModelData.method,
            file_format: generatedModelData.file_format,
            file_size: generatedModelData.file_size
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast('‚úÖ 3D model saved to wardrobe successfully!', 'success');
            currentItemData.model_3d_path = generatedModelData.model_path;
            currentItemData.has_3d_model = true;
            console.log('‚úÖ Manual save completed');
        } else {
            throw new Error(data.error || 'Failed to save model');
        }
    })
    .catch(error => {
        console.error('‚ùå Manual save error:', error);
        showToast(`‚ùå Error saving to wardrobe: ${error.message}`, 'error');
    })
    .finally(() => {
        if (saveBtn) {
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i class="fas fa-save"></i> Save to Wardrobe';
        }
    });
}

function showQuickViewButton() {
    if (generatedModelData && generatedModelData.model_path) {
        const quickViewBtn = document.getElementById('quick-view-button');
        if (quickViewBtn) {
            quickViewBtn.style.display = 'block';
        }
    }
}

// MODAL CONTROL FUNCTIONS
function closeModal() {
    try {
        $('#simple3DModal').modal('hide');
    } catch (error) {
        const modal = document.getElementById('simple3DModal');
        if (modal) {
            modal.style.display = 'none';
            modal.classList.remove('show');
            document.body.classList.remove('modal-open');

            const backdrop = document.querySelector('.modal-backdrop');
            if (backdrop) {
                backdrop.remove();
            }
        }
    }

    if (wardrobeViewer) {
        wardrobeViewer.dispose();
        wardrobeViewer = null;
    }
}

// EVENT HANDLERS
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        const modal = document.getElementById('simple3DModal');
        if (modal && (modal.classList.contains('show') || modal.style.display === 'block')) {
            closeModal();
        }
    }
});

document.addEventListener('click', function(event) {
    const modal = document.getElementById('simple3DModal');
    if (modal && (modal.classList.contains('show') || modal.style.display === 'block')) {
        if (event.target === modal) {
            closeModal();
        }
    }
});

// TOAST NOTIFICATION SYSTEM
function showToast(message, type = 'success', title = '') {
    const toastTemplate = document.getElementById('toast-template');
    const toast = toastTemplate.cloneNode(true);

    toast.id = 'toast-' + Date.now();
    toast.style.display = 'block';
    toast.classList.add(type);

    const iconMap = {
        success: 'fa-check-circle',
        error: 'fa-exclamation-circle',
        warning: 'fa-exclamation-triangle',
        info: 'fa-info-circle'
    };

    const icon = toast.querySelector('.toast-icon i');
    icon.className = `fas ${iconMap[type] || iconMap.success}`;

    const titleElement = toast.querySelector('.toast-title');
    const messageElement = toast.querySelector('.toast-message');

    if (title) {
        titleElement.textContent = title;
    } else {
        titleElement.style.display = 'none';
    }
    messageElement.textContent = message;

    document.body.appendChild(toast);

    setTimeout(() => {
        toast.classList.add('show');
    }, 100);

    setTimeout(() => {
        hideToast(toast);
    }, 5000);
}

function hideToast(toast) {
    toast.classList.remove('show');
    setTimeout(() => {
        if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
        }
    }, 300);
}

// CLEANUP
window.addEventListener('beforeunload', function() {
    if (wardrobeViewer) {
        wardrobeViewer.dispose();
    }
});

// TESTING FUNCTIONS
window.testCleanWhiteViewer = function() {
    const coloredCubeOBJ = `# Colored Test Cube for Clean White Background
v -1 -1 -1 1.0 0.0 0.0
v 1 -1 -1 0.0 1.0 0.0
v 1 1 -1 0.0 0.0 1.0
v -1 1 -1 1.0 1.0 0.0
v -1 -1 1 1.0 0.0 1.0
v 1 -1 1 0.0 1.0 1.0
v 1 1 1 0.5 0.5 0.5
v -1 1 1 0.8 0.8 0.8

f 1 2 3 4
f 5 8 7 6
f 1 5 6 2
f 2 6 7 3
f 3 7 8 4
f 5 1 4 8`;

    generatedModelData = {
        model_path: 'data:text/plain;base64,' + btoa(coloredCubeOBJ),
        method: 'test',
        file_format: 'OBJ',
        file_size: coloredCubeOBJ.length
    };

    console.log('üß™ Test data set for clean white clothing viewer:', generatedModelData);
    view3DModel();
};

window.testWithActualColoredModel = function(modelPath) {
    if (!modelPath) {
        modelPath = '/static/models/generated/a1f71ebb37914b739fa02333ed8a4672/colab_model_task_a1f71ebb37914b739fa02333ed8a4672_46bca89f_1748192740_1748192762.obj';
    }

    generatedModelData = {
        model_path: modelPath,
        method: 'colab',
        file_format: 'OBJ',
        file_size: 6085950
    };

    console.log('üî• TESTING WITH ACTUAL COLORED CLOTHING MODEL:', generatedModelData);
    view3DModel();
};

// Debug function for OBJ color analysis
window.debugOBJColors = async function(objUrl) {
    try {
        const response = await fetch(objUrl);
        const objText = await response.text();

        const lines = objText.split('\n');
        let coloredVertices = 0;
        let totalVertices = 0;

        console.log('üîç Analyzing OBJ file for colors...');

        for (const line of lines.slice(0, 50)) { // Check first 50 lines
            if (line.startsWith('v ')) {
                totalVertices++;
                const parts = line.split(/\s+/);
                if (parts.length >= 7) {
                    coloredVertices++;
                    console.log(`üé® Vertex ${totalVertices}: ${line}`);
                } else {
                    console.log(`‚ö™ Vertex ${totalVertices}: ${line} (no colors)`);
                }
            }
        }

        console.log(`üìä Summary: ${coloredVertices}/${totalVertices} vertices have colors`);

        if (coloredVertices === 0) {
            console.log('‚ùå No colored vertices found in this OBJ file');
        } else {
            console.log('‚úÖ This OBJ file contains color data!');
        }

    } catch (error) {
        console.error('Error analyzing OBJ:', error);
    }
};

// Quick access functions for debugging
window.loadCleanWhiteClothing3D = function(path) {
    generatedModelData = {
        model_path: path,
        method: 'manual',
        file_format: 'OBJ',
        file_size: 0
    };
    view3DModel();
};

console.log('üéâ ENHANCED WARDROBE 3D VIEWER WITH CLEAN WHITE BACKGROUND & COLOR SUPPORT LOADED!');
console.log('‚ú® Features:');
console.log('   üé® Full color support from OBJ vertex colors');
console.log('   ü§ç Clean white professional background');
console.log('   üëï Clothing-optimized camera positioning');
console.log('   üîÑ Clothing-specific view presets (Front, Back, Side, Detail)');
console.log('   üí° Studio-quality lighting for fashion display');
console.log('');
console.log('üß™ Test commands:');
console.log('   window.testCleanWhiteViewer() - Load colored test cube with white background');
console.log('   window.testWithActualColoredModel() - Load your actual colored model');
console.log('   window.debugOBJColors("path") - Analyze OBJ file for color data');
console.log('   window.loadCleanWhiteClothing3D("path") - Load specific model path');
console.log('‚úÖ Clean white clothing viewer with full color support ready!');

</script>
{% endblock %}